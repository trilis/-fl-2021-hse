%{
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <cstring>
#include <set>
#include <cstdlib>
#include <fstream>
using namespace std;

int yylex(); 
int yyerror(const char *p) { cerr << "Error! " << p << endl; exit(1);}

namespace{
struct DFA{
  vector <vector <pair <string, int>>> g;
  map<string, int> num_ver;
  set<int> terms;
  int start = -1;

  bool is_correct(){
    if (start == -1){cerr << "Error! Unable to find start vertex\n"; return false;}
    bool is_complete = g[0].size() != 0;
    int alphabet_size = g[0].size();
    for (const auto& p : g){ is_complete &= alphabet_size == p.size(); }
    if (!is_complete) {cerr << "Error! DFA is not complete\n"; }
    return is_complete;
  }

  bool check_str(ifstream& in){
    int v = start;
    bool go;
    for (char word = in.get(); !in.eof(); in.get(word)){
      go = false;
      for (const auto& edge : g[v]){
        if (word == edge.first[0]){
          v = edge.second;
          go = true;
          break;
        }
      }
      if (!go){ return false; }
    }
    if (terms.find(v) != terms.end()){ return true; }
    else{ return false; }
  }
} dfa;
set<string> cont_vers;
set<string> cont_words;
string vertex_from, vertex_to;

string get_correct_str(const char* s){
  string str = s;
  str.erase(str.find_last_not_of(' ') + 1, str.size());
  str.erase(0, str.find_first_not_of(' '));
  return move(str);
}

void add_word(const char* str){
  string s = get_correct_str(str);
  if (cont_words.find(s) != cont_words.end()){
    cerr << "Error! Attempt to make edge with two similar words: " << s << "\n";
    exit(1);
  }
  cont_words.insert(move(s));
}

void add_ver(const char* str){
  string s = get_correct_str(str);
  if (cont_vers.find(s) != cont_vers.end()){
    cerr << "Error! Attempt to create two similar vertexes: " << s << "\n";
    exit(1);
  }
  cont_vers.insert(move(s));
}
}

%}

%union{
  char* kw;
  char* ver;
  char* word;
  char* op;
};
%token <kw>   KW
%token <ver>  VER
%token <word> WORD
%token <op>   COMMA SEMICOLON COLON ARROW QUOTE
%type  <tag>  discr str ver_l word_l ver_from ver_to

%%

start: discr{ }

discr: discr str SEMICOLON{ }
| str SEMICOLON{ }

str: KW ver_l{
  if (strncmp($1, "terminal", 8) == 0){
    for (const string& s : cont_vers){
      dfa.terms.insert(dfa.num_ver[s]);
    }
  }else if (strncmp($1, "start", 5) == 0){
    if (cont_vers.size() != 1) {
      cerr << "Error! Too many start vertexes\n";
      exit(1);
    }
    dfa.start = dfa.num_ver[*cont_vers.begin()];
  }else{
    for (const string& s : cont_vers){
      dfa.num_ver[s] = dfa.g.size();
      dfa.g.push_back(vector <pair <string, int>>());
    }
  }
  cont_vers.clear();
}
| ver_from ARROW ver_to COLON QUOTE word_l QUOTE { 
  int a = dfa.num_ver[vertex_from];
  int b = dfa.num_ver[vertex_to];
  for (const string& s : cont_words){
    dfa.g[a].push_back({s, b});
  }
  cont_vers.clear();
  cont_words.clear();
}

ver_l: ver_l COMMA VER { add_ver($3); }
| VER { add_ver($1); }

ver_from: VER { vertex_from = get_correct_str($1); }

ver_to: VER{ vertex_to = get_correct_str($1); }

word_l: word_l COMMA WORD { add_word($3); }
| WORD { add_word($1);  }


%%

int main(int argc, char* argv[])
{
  yyparse();
  if (!dfa.is_correct()){ return 1; }
  if (argc < 2) { 
    cerr << "Error! Usage: " << argv[0] << " <file> < <automata>\n";
    return 1;
  }
  ifstream in(argv[1]);
  if (!in.is_open()){
    cerr << "Error! Unable to open " << argv[1] << " for reading\n";
    return 1;
  }
  if (dfa.check_str(in)){
    cout << "The string belong to the automaton\n";
  }else{
    cout << "The string doesn't belong to the automaton\n";
  }
  in.close();
  return 0;
}
