# Отчет
Код алгоритма находится в файлах `regexp.hpp`, `regexp.cpp`.
Небольшая обертка для тестирования находится в файлике `tests.hpp`  
Тесты находятся в файле `main.cpp`.  
* Без каких либо оптимизаций: результаты тестов лежат в файлике `before_opt.txt`. Первые замеры, не очень понятно с чем сравнивать(в ветке HW03 лежат дополненные тесты, т.к. по итогу на этих тестах решение без каких-либо улучшений за разумное время не отрабатывало, точные тесты можно посмотреть в коммите `b2bd8919939b5ed12d964f41331a4704288c7366`).
* Изменил возвращающее значение `Nullable` на `bool`. Время работы уменьшилось на 1-2 порядка. Добавил более большие тесты, т.к. предыдущие оно почти не замечало.
Результаты тестов находятся в файле `after_nullable_as_bool.txt`. 
* Сделал все оптимизации из задания, кроме проверки на равенство регулярок. Это при текущей реализации сделать трудозатратно, т.к. я все храню на указателях и пришлось бы тащить за собой весь тип дерева регулярки. На данный момент сравниваю просто указатели, если они совпадают, то не делаю лишние операции. Случай, когда две регулярки равны, но у них разные указатели при текущей реализации редок, т.к. для этого пользователю надо руками создавать две одинаковые регулярки. Время всех тестов уменьшилось до одной миллисекунды. Добавил более больших тестов, однако более 5 мс. программа не работает. Результаты тестов находятся в файле `after_opt.txt`.   

### TL;DR
#### Максимальное время работы
Без оптимизаций: 9.5 сек., регулярка: `(ab)*****`, строка `abababab`   
Nullable as bool: 0.371 сек., регулярка `(ab)*`, строка `abababababababababababababababababababababababababababababababababababababababababababab`  
Со всеми оптимизациями: на всех примерах ~0.001 сек и менее.
